{
  "name": "nools",
  "description": "A rules engine for node",
  "version": "0.1.14",
  "bin": {
    "nools": "./bin/nools"
  },
  "keywords": [
    "rules",
    "flow",
    "rules engine",
    "rools",
    "drools",
    "async",
    "flow control"
  ],
  "repository": {
    "type": "git",
    "url": "git@github.com:C2FO/nools.git"
  },
  "dependencies": {
    "declare.js": "~0.0.3",
    "extended": "~0.0.3",
    "is-extended": "~0.0.4",
    "string-extended": "~0.0.3",
    "array-extended": "~0.0.4",
    "date-extended": "~0.0.3",
    "function-extended": "~0.0.3",
    "object-extended": "~0.0.3",
    "promise-extended": "~0.0.3",
    "arguments-extended": "~0.0.3",
    "leafy": "~0.0.2",
    "ht": "~0.0.2",
    "commander": "~1.1.1",
    "uglify-js": "~2.3.6"
  },
  "devDependencies": {
    "grunt": "~0.4.1",
    "it": "~0.2.0",
    "jison": ">=0.3.2",
    "grunt-it": "~0.3.0",
    "grunt-contrib-uglify": "~0.2.0",
    "grunt-contrib-jshint": "~0.5.3",
    "grunt-browserify": "1.2.4"
  },
  "testling": {
    "files": "test/browserling.js",
    "browsers": [
      "ie/8..latest",
      "chrome/20..latest",
      "firefox/14..latest",
      "safari/latest",
      "iphone/6",
      "ipad/6"
    ]
  },
  "homepage": "http://c2fo.github.com/nools",
  "author": {
    "name": "Doug Martin",
    "url": "http://c2fo.com"
  },
  "main": "index.js",
  "scripts": {
    "test": "it -r dot",
    "create-doc": "rm -rf docs/* && coddoc -d ./lib -f multi-html"
  },
  "directories": {
    "lib": "lib"
  },
  "engines": {
    "node": ">= 0.6.1"
  },
  "readme": "[![Build Status](https://travis-ci.org/C2FO/nools.png)](https://travis-ci.org/C2FO/nools)\n\n[![browser support](https://ci.testling.com/C2FO/nools.png)](https://ci.testling.com/C2FO/nools)\n\n# Nools\n\nNools is a [rete](http://en.wikipedia.org/wiki/Rete_algorithm) based rules engine written entirely in javascript.\n\n# Installation\n\n```\nnpm install nools\n```\nOr [download the source](https://raw.github.com/C2FO/nools/master/nools.js) ([minified](https://raw.github.com/C2FO/nools/master/nools.min.js))\n\n\n# Usage\n\n   * Flows\n    * [Defining A Flow](#flow) \n    * [Sessions](#session) \n    * [Facts](#facts) \n    * [Firing](#firing) \n    * [Disposing](#disposing)\n    * [Removing A Flow](#removing-flow)\n    * [Removing All Flows](#removing-flows)\n    * [Checking If A Flow Exists](#checking-for-flow)\n    * [Agenda Group](#agenda-groups)\n      * [Focus](#agenda-groups-focus)\n      * [Auto Focus](#agenda-groups-auto-focus)\n   * [Defining Rules](#defining-rule)\n      * [Structure](#rule-structure)\n      * [Salience](#rule-salience)\n      * [Scope](#rule-scope)\n      * [Constraints](#constraints)\n      * [Actions](#action)\n      * [Globals](#globals)\n      * [Import](#import)\n   * [Browser Support](#browser-support)\n   * [Fibonacci](#fib)\n      \n   \n\nThe [examples](https://github.com/C2FO/nools/tree/master/examples) and [tests](https://github.com/C2FO/nools/tree/master/test) are a\ngreat place to get started. You can ask your questions on the [Nools Google group](https://groups.google.com/forum/#!forum/nools).\n\n<a name=\"flow\"></a>\n## Defining a flow\n\nWhen using nools you define a **flow** which acts as a container for rules that can later be used to get\na **session**\n\n### Programmatically\n```javascript\nvar nools = require(\"nools\");\n\nvar Message = function (message) {\n    this.message = message;\n};\n\nvar flow = nools.flow(\"Hello World\", function (flow) {\n\n    //find any message that start with hello\n    flow.rule(\"Hello\", [Message, \"m\", \"m.message =~ /^hello(\\\\s*world)?$/\"], function (facts) {\n        facts.m.message = facts.m.message + \" goodbye\";\n        this.modify(facts.m);\n    });\n\n    //find all messages then end in goodbye\n    flow.rule(\"Goodbye\", [Message, \"m\", \"m.message =~ /.*goodbye$/\"], function (facts) {\n        console.log(facts.m.message);\n    });\n});\n\n```\n\nIn the above flow definition 2 rules were defined\n\n  * Hello\n    * Requires a Message\n    * The messages's message must match the regular expression \"/^hello(\\\\s*world)?$/\"\n    * When matched the message's message is modified and then we let the engine know that we modified the message.\n  * Goodbye\n    * Requires a Message\n    * The messages's message must match the regular expression \"/.*goodbye$/\"(anything that ends in goodbye)\n    * When matched the resulting message is logged.\n\n### DSL\n\nYou may also use the `nools` rules language to define your rules.\n\nThe following is the equivalent of the rules defined programmatially above.\n\n```\ndefine Message {\n    message : '',\n    constructor : function(message){\n        this.message = message;\n    }\n}\n\n//find any message that start with hello\nrule Hello {\n    when {\n        m : Message m.message =~ /^hello(\\\\s*world)?$/;\n    }\n    then {\n        modify(m, function(){this.message += \" goodbye\";});\n    }\n}\n\n//find all messages then end in goodbye\nrule Goodbye {\n    when {\n        m : Message m.message =~ /.*goodbye$/;\n    }\n    then {\n        console.log(m.message);\n    }\n}\n```\n\nTo use the flow\n\n```javascript\nvar flow = nools.compile(__dirname + \"/helloworld.nools\"),\n    Message = flow.getDefined(\"message\");\n```\n\n### Flow Events\n\nEach flow can have the following events emitted.\n\n* `assert (fact)` - emitted when facts are asserted\n* `retract (fact)` - emitted when facts are retracted\n* `modify (fact)` - emitted when facts are modified\n* `fire (name, rule)` - emitted when an activation is fired.\n\n```\nsession.on(\"assert\", function(fact){\n    //fact was asserted\n});\n\nsession.on(\"retract\", function(fact){\n    //fact was retracted\n});\n\nsession.on(\"modify\", function(fact){\n    //fact was modifed\n});\n\nsession.on(\"fire\", function(name, rule){\n    //a rule was fired.\n});\n```\n\n### `nools.compile`\n\nThe compile method accepts the following parameters\n\n* `source|path` - The first argument must either be a path that ends in `.nools` or a string which is the source of the rules that you wish to compile.\n* `options?`\n   * `name` : This is the name of the flow. You can use this name to look up the flow by using `nools.getFlow`.\n   * `define` : A hash of Classes that should be aviable to the rules that you are compiling.\n   * `scope`: A hash of items that should be available to rules as they run. (i.e. a logger)\n* `cb?` - an options function to invoke when compiling is done.\n\n\n**Example**\n\n```\nrule \"person name is bob\" {\n    when {\n        p : Person p.name == 'bob';\n    }\n    then {\n        logger.info(\"Found person with name of bob\");\n        retract(p);\n    }\n}\n```\n\nIn the above rules file we make use of a Person class and a logger. In order for nools to properly reference the Class and logger you must specify them in your options.\n\n```javascript\nvar flow = nools.compile(\"personFlow.nools\", {\n    define: {\n        //The person class the flow should use\n        Person: Person\n    },\n    scope: {\n        //the logger you want your flow to use.\n        logger: logger\n    }\n});\n```\n\nYou may also compile source directly.\n\n```javascript\nvar noolsSource = \"rule 'person name is bob' {\"\n    + \"   when {\"\n    + \"     p : Person p.name == 'bob';\"\n    + \"   }\"\n    + \"   then {\"\n    + \"       logger.info('Found person with name of bob');\"\n    + \"       retract(p);\"\n    + \"   }\"\n    + \"}\";\n\nvar flow = nools.compile(noolsSource, {\n    define: {\n        //The person class the flow should use\n        Person: Person\n    },\n    scope: {\n        //the logger you want your flow to use.\n        logger: logger\n    }\n});\n```\n\n<a name=\"session\"></a>\n## Working with a session\n\nA session is an instance of the flow that contains a working memory and handles the assertion, modification, and retraction of facts from the engine.\n\nTo obtain an engine session from the flow invoke the  `getSession` method.\n\n```javascript\nvar session = flow.getSession();\n```\n\n<a name=\"facts\"></a>\n## Working with facts\n\nFacts are items that the rules should try to match.\n\n\nTo add facts to the session use **assert** method.\n\n```javascript\nsession.assert(new Message(\"hello\"));\nsession.assert(new Message(\"hello world\"));\nsession.assert(new Message(\"goodbye\"));\n```\n\nAs a convenience any object passed into **getSession** will also be asserted.\n\n```javascript\nflow.getSession(new Message(\"hello\"), new Message(\"hello world\"), new Message(\"goodbye\"));\n```\n\nTo retract facts from the session use the **retract** method.\n\n```javascript\nvar m = new Message(\"hello\");\n\n//assert the fact into the engine\nsession.assert(m);\n\n//remove the fact from the engine\nsession.retract(m);\n\n```\n\nTo modify a fact use the **modify** method.\n\n**Note** modify will not work with immutable objects (i.e. strings). \n\n```javascript\n\nvar m = new Message(\"hello\");\n\nsession.assert(m);\n\nm.message = \"hello goodbye\";\n\nsession.modify(m);\n\n```\n\n**assert** is typically used pre engine execution and during the execution of the rules.\n\n**modify** and **retract** are typically used during the execution of the rules.\n\n\n<a name=\"firing\"></a>\n## Firing the rules\n\nWhen you get a session from a **flow** no rules will be fired until the **match** method is called.\n\n```javascript\nvar session = flow.getSession();\n//assert your different messages\nsession.assert(new Message(\"goodbye\"));\nsession.assert(new Message(\"hello\"));\nsession.assert(new Message(\"hello world\"));\n\n//now fire the rules\nsession.match(function(err){\n    if(err){\n        console.error(err);\n    }else{\n        console.log(\"done\");\n    }\n})\n```\n\nThe **match** method also returns a promise that is resolved once there are no more rules to activate.\n\n```javascript\nsession.match().then(\n  function(){\n      console.log(\"Done\");\n  }, \n  function(err){\n    //uh oh an error occurred\n    console.error(err);\n  });\n```\n\n## Fire until halt\n\nYou may also run the engine an a \"reactive\" mode which will continue to match until `halt` is invoked.\n\nIn the following example the rules engine continues to evaluate until the counter reaches `10000`. If you remove the \"counted to high\" rule then the engine would run indefinitely.\n\n```javascript\n\ndefine Counter {\n    count: 0,\n    constructor: function(count){\n        this.count = count;\n    }\n}\n\n//We reached our goal\nrule \"I can count!\" {\n    when {\n        $ctr: Counter $ctr.count == 10000;\n    }\n    then{\n        console.log(\"Look ma! I counted to \" + $ctr.count);\n        halt();\n    }\n}\n\n//no counter was asserted so create one\nrule \"not count\" {\n    when {\n        not($ctr: Counter);\n    }\n    then{\n        console.log(\"Imma gonna count!\");\n        assert(new Counter(1));\n    }\n}\n\n//A little status update\nrule \"give them an update\" {\n    when{\n        $ctr: Counter $ctr.count % 1000 == 0 {count: $count}\n    }\n    then{\n        console.log(\"Imma countin...\");\n        modify($ctr, function(){this.count = $count + 1;});\n    }\n}\n\n//just counting away\nrule count {\n    when{\n        $ctr: Counter {count: $count}\n    }\n    then{\n        modify($ctr, function(){this.count = $count + 1;});\n    }\n}\n\n```\n\n```javascript\nflow.getSession().matchUntilHalt(function(err){\n    if(err){\n        console.log(err.stack);\n        return;\n    }\n    //halt finally invoked\n});\n```\n\n`matchUntilHalt` also returns a promise.\n\n\n```javascript\nflow.getSession().matchUntilHalt()\n    .then(\n        function(){\n            //all done!\n        },\n        function(err){\n            console.log(err.stack);\n        }\n    );\n```\n\n\n\n<a name=\"disposing\"></a>\n## Disposing of the session\n\nWhen working with a lot of facts it is wise to call the `dispose` method which will purge the current session of\nall facts, this will help prevent the process from growing a large memory footprint.\n\n```javascript\nsession.dispose();\n```\n\n<a name=\"removing-flow\"></a>\n# Removing a flow\n\nTo remove a defined flow from `nools` use the `deleteFlow` function.\n\n```javascript\nvar myFlow = nools.flow(\"flow\");\n\nnools.deleteFlow(\"flow\"); //returns nools for chaining\n\nnools.getFlow(\"flow\"); //undefined\n\n```\n\nYou may also remove a flow using the `FlowContainer` object returned from nools.flow;\n\n```javascript\nvar myFlow = nools.flow(\"flow\");\n\nnools.deleteFlow(myFlow); //returns nools for chaining\n\nnools.getFlow(\"flow\"); //undefined\n```\n\n<a name=\"removing-flows\"></a>\n# Removing All Flows\n\nTo remove all flow from `nools` use the `deleteFlows` function.\n\n```javascript\nvar myFlow = nools.flow(\"flow\");\n\nnools.deleteFlows(); //returns nools for chaining\n\nnools.getFlow(\"flow\"); //undefined\n\n```\n\n\n<a name=\"checking-for-flow\"></a>\n# Checking If A Flow Exists\n\nTo check if a flow currently is registering with `nools` use the `hasFlow` function;\n\n```javascript\nvar myFlow = nools.flow(\"flow\");\n\nnools.hasFlow(\"flow\"); //true\n\n```\n\n<a name=\"agenda-groups\"></a>\n## Agenda Groups\n\nAgenda groups allow for logical groups of rules within a flow.\n\nThe agenda manages a `stack` of `agenda-groups` that are currently in focus. The default `agenda-group` is called `main` and all rules that do not have an `agenda-group` specified are placed into the `main` `agenda-group`.\n\nAs rules are fired when a particular `agenda-group` runs out of activations then that a `agenda-group` is popped from the internal `agenda-group` stack and the next one comes into focus. This continues until `focus` is explicitly called again or the `main` `agenda-group` comes into focus.\n\n**Note** Once an agenda group loses focus it must be re-added to the stack in order for those activations to be focused again.\n\nTo add a rule to an agenda-group you can use the `agendaGroup` option.\n\n```javascript\nthis.rule(\"Hello World\", {agendaGroup: \"ag1\"}, [Message, \"m\", \"m.name == 'hello'\"], function (facts) {\n    this.modify(facts.m, function () {\n        this.name = \"goodbye\";\n    });\n});\n\nthis.rule(\"Hello World2\", {agendaGroup: \"ag2\"}, [Message, \"m\", \"m.name == 'hello'\"], function (facts) {\n    this.modify(facts.m, function () {\n        this.name = \"goodbye\";\n    });\n});\n```\n\nOr in the dsl\n\n```\nrule \"Hello World\" {\n    agenda-group: \"ag1\";\n    when{\n        m : Message m.name == 'hello';\n    }\n    then{\n        modify(m, function(){\n            this.name = \"goodbye\"\n        });\n    }\n}\n\nrule \"Hello World 2\" {\n    agenda-group: \"ag2\";\n    when{\n        m : Message m.name == 'hello';\n    }\n    then {\n        modify(m, function(){\n            this.name = \"goodbye\"\n        });\n    }\n}\n```\n\nIn the above rules we have defined two agenda-groups called `ag1` and `ag2`\n\n<a name=\"agenda-groups-focus\"></a>\n### Focus\n\nWhen running your rules and you want a particular agenda group to run you must call `focus` on the flow and specify the `agenda-group` to add to the stack.\n\n```\n//assuming a flow with the rules specified above.\nvar fired = [];\nflow\n   .focus(\"ag1\")\n   .on(\"fire\", function(ruleName){\n      fired.push(ruleName); //[ 'Hello World' ]\n   })\n   .assert(new Message(\"hello\"))\n   .match(function(){\n        console.log(fired);\n   });\n```\n\nOr you can add multiple focuses to the stack\n\n```javascript\nvar fired = [], fired2 = [];\nflow\n    .getSession(new Message(\"hello\"))\n    .focus(\"ag2\")\n    .focus(\"ag1\")\n    .on(\"fire\", function (ruleName) {\n       fired.push(ruleName);\n    })\n    .match(function () {\n        console.log(fired); //[ 'Hello World', 'Hello World2' ]\n    });\n\nflow\n    .getSession(new Message(\"hello\"))\n    .focus(\"ag1\")\n    .focus(\"ag2\")\n    .on(\"fire\", function (ruleName) {\n       fired2.push(ruleName);\n    })\n    .match(function () {\n        console.log(fired2); //[ 'Hello World2', 'Hello World' ]\n    });\n```\n\nNotice above that the last `agenda-group` focused is added to the array first.\n\n<a name=\"agenda-groups-auto-focus\"></a>\n### Auto Focus\n\nSometimes you may want an `agenda-group` to `auto-focus` whenever a certain rule is activated.\n\n```\nthis.rule(\"Bootstrap\", [State, \"a\", \"a.name == 'A' && a.state == 'NOT_RUN'\"], function (facts) {\n    this.modify(facts.a, function () {\n        this.state = 'FINISHED';\n    });\n});\n\nthis.rule(\"A to B\",\n    [\n        [State, \"a\", \"a.name == 'A' && a.state == 'FINISHED'\"],\n        [State, \"b\", \"b.name == 'B' && b.state == 'NOT_RUN'\"]\n    ],\n    function (facts) {\n        this.modify(facts.b, function () {\n            this.state = \"FINISHED\";\n        });\n    });\n\nthis.rule(\"B to C\",\n    {agendaGroup: \"B to C\", autoFocus: true},\n    [\n        [State, \"b\", \"b.name == 'B' && b.state == 'FINISHED'\"],\n        [State, \"c\", \"c.name == 'C' && c.state == 'NOT_RUN'\"]\n    ],\n    function (facts) {\n        this.modify(facts.c, function () {\n            this.state = 'FINISHED';\n        });\n        this.focus(\"B to D\");\n    });\n\nthis.rule(\"B to D\",\n    {agendaGroup: \"B to D\"},\n    [\n        [State, \"b\", \"b.name == 'B' && b.state == 'FINISHED'\"],\n        [State, \"d\", \"d.name == 'D' && d.state == 'NOT_RUN'\"]\n    ],\n    function (facts) {\n        this.modify(facts.d, function () {\n        this.state = 'FINISHED';\n    });\n});\n```\n\nOr using the dsl\n\n```\nrule Bootstrap {\n    when{\n        a : State a.name == 'A' && a.state == 'NOT_RUN';\n    }\n    then{\n        modify(a, function(){\n            this.state = 'FINISHED';\n        });\n    }\n}\n\n\nrule 'A to B' {\n    when{\n        a : State a.name == 'A' && a.state == 'FINISHED';\n        b : State b.name == 'B' && b.state == 'NOT_RUN';\n    }\n    then{\n        modify(b, function(){\n            this.state = 'FINISHED';\n        });\n    }\n}\n\nrule 'B to C' {\n    agenda-group: 'B to C';\n    auto-focus: true;\n    when{\n        b: State b.name == 'B' && b.state == 'FINISHED';\n        c : State c.name == 'C' && c.state == 'NOT_RUN';\n    }\n    then{\n        modify(c, function(){\n            this.state = 'FINISHED';\n        });\n        focus('B to D')\n    }\n}\n\nrule 'B to D' {\n    agenda-group: 'B to D';\n    when{\n        b: State b.name == 'B' && b.state == 'FINISHED';\n        d : State d.name == 'D' && d.state == 'NOT_RUN';\n    }\n    then{\n        modify(d, function(){\n            this.state = 'FINISHED';\n        });\n    }\n}\n```\n\nIn the above rules we created a state machine that has a rule with `auto-focus` set to true.\n\nThis allows you to not have to specify `focus` when running the flow.\n\n```javascript\nvar fired = [];\nflow\n    .getSession(\n        new State(\"A\", \"NOT_RUN\"),\n        new State(\"B\", \"NOT_RUN\")),\n        new State(\"C\", \"NOT_RUN\")),\n        new State(\"D\", \"NOT_RUN\")\n    )\n    .on(\"fire\", function (name) {\n        fired.push(name);\n    })\n    .match()\n    .then(function () {\n        console.log(fired); //[\"Bootstrap\", \"A to B\", \"B to C\", \"B to D\"]\n    });\n```\n\n<a name=\"defining-rule\"></a>\n# Defining rules\n\n<a name=\"rule structure\"></a>\n## Rule structure\n\nLets look at the \"Calculate\" rule in the [Fibonacci](#fib) example\n\n```javascript\n   //flow.rule(type[String|Function], constraints[Array|Array[[]]], action[Function]);\n   flow.rule(\"Calculate\", [\n         //Type     alias  pattern           store sequence to s1\n        [Fibonacci, \"f1\",  \"f1.value != -1\", {sequence:\"s1\"}],\n        [Fibonacci, \"f2\", \"f2.value != -1 && f2.sequence == s1 + 1\", {sequence:\"s2\"}],\n        [Fibonacci, \"f3\", \"f3.value == -1 && f3.sequence == s2 + 1\"],\n        [Result, \"r\"]\n    ], function (facts) {\n        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\n        var v = f3.value = f1.value + facts.f2.value;\n        facts.r.result = v;\n        this.modify(f3);\n        this.retract(f1);\n    });\n```\n\nOr using the nools DSL\n\n```\nrule Calculate{\n    when {\n        f1 : Fibonacci f1.value != -1 {sequence:s1};\n        f2 : Fibonacci f2.value != -1 && f2.sequence == s1 + 1 {sequence:s2};\n        f3 : Fibonacci f3.value == -1 && f3.sequence == s2 + 1;\n    }\n    then {\n       modify(f3, function(){\n            this.value = f1.value + f2.value;\n       });\n       retract(f1);\n    }\n}\n```\n\n<a name=\"rule-salience\"></a>\n### Salience\n\nSalience is an option that can be specified on a rule giving it a priority and allowing the developer some control over conflict resolution of activations.\n\n```javascript\nthis.rule(\"Hello4\", {salience: 7}, [Message, \"m\", \"m.name == 'Hello'\"], function (facts) {\n});\n\nthis.rule(\"Hello3\", {salience: 8}, [Message, \"m\", \"m.name == 'Hello'\"], function (facts) {\n});\n\nthis.rule(\"Hello2\", {salience: 9}, [Message, \"m\", \"m.name == 'Hello'\"], function (facts) {\n});\n\nthis.rule(\"Hello1\", {salience: 10}, [Message, \"m\", \"m.name == 'Hello'\"], function (facts) {\n});\n```\n\nIn the above flow we define four rules each with a different salience, when a single message is asserted they will fire in order of salience (highest to lowest).\n\n```javascript\nvar fired = [];\nflow1\n    .getSession(new Message(\"Hello\"))\n    .on(\"fire\", function (name) {\n        fired.push(name);\n    })\n    .match()\n    .then(function(){\n        console.log(fired); //[\"Hello1\", \"Hello2\", \"Hello3\", \"Hello4\"]\n    });\n```\n\n\n\n<a name=\"rule-scope\"></a>\n### Scope\n\nScope allows you to access function from within your rules.\n\nIf you are using vanilla JS you can use the `scope` option when defining your rule.\n\n```javascript\n\nthis.rule(\"hello rule\", {scope: {isEqualTo: isEqualTo}},\n   [\n      [\"or\",\n         [String, \"s\", \"isEqualTo(s, 'hello')\"],\n         [String, \"s\", \"isEqualTo(s, 'world')\"]\n      ],\n      [Count, \"called\", null]\n   ],\n   function (facts) {\n      facts.called.called++;\n   });\n\n\n```\n\nIf you are using the dsl.\n\n```\nfunction matches(str, regex){\n    return regex.test(str);\n}\n\nrule Hello {\n    when {\n        m : Message matches(m.message, /^hello(\\\\s*world)?$/);\n    }\n    then {\n        modify(m, function(){\n            this.message += \" goodbye\";\n        })\n    }\n}\n\nrule Goodbye {\n    when {\n        m : Message matches(m.message, /.*goodbye$/);\n    }\n    then {\n    }\n}\n```\n\nOr you can pass in a custom function using the scope option in compile.\n\n```\nrule Hello {\n    when {\n        m : Message doesMatch(m.message, /^hello(\\\\s*world)?$/);\n    }\n    then {\n        modify(m, function(){\n            this.message += \" goodbye\";\n        })\n    }\n}\n\nrule Goodbye {\n    when {\n        m : Message doesMatch(m.message, /.*goodbye$/);\n    }\n    then {\n    }\n}\n```\n\nProvided the `doesMatch` function in the scope option of compile.\n\n```javascript\nfunction matches(str, regex) {\n   return regex.test(str);\n};\nvar flow = nools.compile(__dirname + \"/rules/provided-scope.nools\", {scope: {doesMatch: matches}});\n```\n\n<a name=\"constraints\"></a>\n### Constraints\n\nConstraints define what facts the rule should match. The constraint is a array of either a single constraint (i.e. Bootstrap rule) or an array of constraints(i.e. Calculate).\n\nProgrammatically\n\n```javascript\n[\n   //Type     alias  pattern           store sequence to s1\n  [Fibonacci, \"f1\", \"f1.value != -1\", {sequence:\"s1\"}],\n  [Fibonacci, \"f2\", \"f2.value != -1 && f2.sequence == s1 + 1\", {sequence:\"s2\"}],\n  [Fibonacci, \"f3\", \"f3.value == -1 && f3.sequence == s2 + 1\"],\n  [Result, \"r\"]\n]\n```\n\nUsing nools DSL\n\n```\nwhen {\n    f1 : Fibonacci f1.value != -1 {sequence:s1};\n    f2 : Fibonacci f2.value != -1 && f2.sequence == s1 + 1 {sequence:s2};\n    f3 : Fibonacci f3.value == -1 && f3.sequence == s2 + 1;\n}\n```\n\n   1. Type -  is the Object type the rule should match. The available types are\n      * `String` - \"string\", \"String\", String\n      * `Number` - \"number\", \"Number\", Number\n      * `Boolean` - \"boolean\", \"Boolean\", Boolean\n      * `Date` - \"date\", \"Date\", Date\n      * `RegExp` - \"regexp\", \"RegExp\", RegExp\n      * `Array` - \"array\", \"Array\", [], Array\n      * `Object` - \"object\", \"Object\", \"hash\", Object\n      * Custom - any custom type that you define\n   2. Alias - the name the object should be represented as.\n   3. Pattern(optional) - The pattern that should evaluate to a boolean, the alias that was used should be used to reference the object in the pattern. Strings should be in single quotes, regular expressions are allowed. Any previously define alias/reference can be used within the pattern. Available operators are.\n      * `&&`, `AND`, `and`\n      * `||`, `OR`, `or`\n      * `>`, `<`, `>=`, `<=`, `gt`, `lt`, `gte`, `lte`\n      * `==`, `!=`, `=~`, `!=~`, `eq`, `neq`, `like`, `notLike`\n      * `+`, `-`, `*`, `/`, `%`\n      * `-` (unary minus)\n      * `.` (member operator)\n      * `in` (check inclusion in an array)\n      * `notIn` (check that something is not in an array)\n      * Defined helper functions\n        * `now` - the current date\n        * `Date(year?, month?, day?, hour?, minute?, second?, ms?)` - creates a new `Date` object\n        * `lengthOf(arr, length)` - checks the length of an array\n        * `isTrue(something)` - check if something === true         \n        * `isFalse(something)` - check if something === false\n        * `isRegExp(something)` - check if something is a `RegExp`\n        * `isArray(something)` - check if something is an `Array`                                \n        * `isNumber(something)` - check if something is an `Number`\n        * `isHash(something)` - check if something is strictly an `Object`\n        * `isObject(something)` - check if something is any type of `Object`\n        * `isDate(something)` - check if something is a `Date`\n        * `isBoolean(something)` - check if something is a `Boolean`\n        * `isString(something)` - check if something is a `String`\n        * `isUndefined(something)` - check if something is a `undefined`\n        * `isDefined(something)` - check if something is `Defined`\n        * `isUndefinedOrNull(something)` - check if something is a `undefined` or `null`\n        * `isPromiseLike(something)` - check if something is a \"promise\" like (containing `then`, `addCallback`, `addErrback`)\n        * `isFunction(something)` - check if something is a `Function`\n        * `isNull(something)` - check if something is `null`\n        * `isNotNull(something)` - check if something is not null\n        * `dateCmp(dt1, dt2)` - compares two dates return 1, -1, or 0\n        * `years|months|days|hours|minutes|seconds``Ago`/`FromNow``(interval)` - adds/subtracts the date unit from the current time \n        \n   4. Reference(optional) - An object where the keys are properties on the current object, and values are aliases to use. The alias may be used in succeeding patterns.\n\n<a name=\"action\"></a>\n\n### Action\n\nThe action is a function that should be fired when all patterns in the rule match. The action is called in the scope\nof the engine so you can use `this` to `assert`, `modify`, or `retract` facts. An object containing all facts and\nreferences created by the alpha nodes is passed in as the first argument to the action.\n\nSo calculate's action modifies f3 by adding the value of f1 and f2 together and modifies f3 and retracts f1.\n\n```javascript\nfunction (facts) {\n        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\n        var v = f3.value = f1.value + facts.f2.value;\n        facts.r.result = v;\n        this.modify(f3);\n        this.retract(f1);\n    }\n```\n\nThe session is also passed in as a second argument so alternatively you could do the following.\n\n```javascript\nfunction (facts, session) {\n        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\n        var v = f3.value = f1.value + facts.f2.value;\n        facts.r.result = v;\n        session.modify(f3);\n        session.retract(f1);\n    }\n```\n\nIf you have an async action that needs to take place an optional third argument can be passed in which is a function \nto be called when the action is completed.\n\n```javascript\nfunction (facts, engine, next) {\n        //some async action\n        process.nextTick(function(){\n            var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\n            var v = f3.value = f1.value + facts.f2.value;\n            facts.r.result = v;\n            engine.modify(f3);\n            engine.retract(f1);\n            next();\n        })\n    }\n```\nIf any arguments are passed into next it is assumed there was an error and the session will error out.\n\nTo define the action with the nools DSL\n\n```\nthen {\n    modify(f3, function(){\n        this.value = f1.value + f2.value;\n    });\n    retract(f1);\n}\n```\n\nFor rules defined using the rules language nools will automatically determine what parameters need to be passed in based on what is referenced in the action.\n\n<a name=\"globals\"></a>\n\n### Globals\n\nGlobals are accessible through the current working scope of rules defined in a `dsl`, very similar to using the `scope` option when compiling.\n\n**Note**  `globals` are not part of the working memory and therefore are not accessible in the LHS (when) or your rule.\n\nGlobals are used like the following:\n\n```\nglobal PI = Math.PI;\nglobal SOME_STRING = 'some string';\nglobal TRUE = true;\nglobal NUM = 1.23;\nglobal DATE = new Date();\n\nrule \"A Rule\" {\n    when {\n    \t$obj: Object;\n    }\n    then{\n    \tconsole.log(PI); //Math.PI;\n    \tconsole.log(SOME_STRING); //\"some string\"\n    \tconsole.log(TRUE); //true\n    \tconsole.log(NUM); //1.23\n    \tconsole.log(DATE); //Thu May 23 2013 15:49:22 GMT-0500 (CDT)\n    }\n}\n```\n\nIf you are using `nools` in `node` you can also use a require statement.\n\n**NOTE** require does not currently work for relative paths.\n\n```\nglobal util = require(\"util\");\n\nrule \"A Rule\" {\n    when {\n    \t$obj: Object;\n    }\n    then{\n    \tutil.log(\"HELLO WORLD\");\n    }\n}\n```\n\n<a name=\"import\"></a>\n\n### Importing\n\nThe `import` statement allows you to import other `nools` files into the current one. This can be used to split up logical flows into small reusable groups of rules.\n\nDefine our common model to be used across our flows.\n\n```\n//define.nools\ndefine Count{\n    constructor: function(){\n        this.called = 0;\n    }\n}\n```\n\nCreate a rules file which imports the `define.nools` to define our `Count` model.\n\n```\n//orRule.nools\n\n//import define.nools\nimport(\"./define.nools\");\nrule orRule {\n    when {\n        or(\n            s : String s == 'hello',\n            s : String s == 'world'\n        );\n        count : Count;\n    }\n    then {\n        count.called++;\n        count.s = s;\n    }\n}\n```\n\nSame as `orRule.nools` import our `define.nools`\n\n```\n//notRule.nools\nimport(\"./defines.nools\");\nrule notRule {\n    when {\n        not(s : String s == 'hello');\n        count : Count\n    }\n    then {\n        count.called++;\n    }\n}\n```\n\nNow we can use `orRule.nools` and `notRule.nools` to compose a new flow that contains `define.nools`, `orRule.nools` and `notRule.nools`.\n\n\n**Note** `nools` will handle duplicate imports, in this case `define.nools` will only be imported once.\n\n```\n//import\nimport(\"./orRules.nools\");\nimport(\"./notRules.nools\");\n```\n\n\n## Emitting custom events.\n\nYou may also emit events from your rule actions using the sessions emit function.\n\n```\nthen {\n    modify(f3, function(){\n        this.value = f1.value + f2.value;\n    });\n    retract(f1);\n    emit(\"my custom event\");\n}\n```\n\nTo listen to the event just use the on method of the session.\n\n```\nvar session = flow.getSession();\n\nsession.on(\"my custom event\", function(){\n    //custom event called.\n});\n\n```\n\n# Browser Support\n\n<a name=\"browser-support\"></a>\n\n`Nools` can also be used in the browser. The only difference is that you cannot pass a file location to the compile method instead you must provide the source.\n\nNools is compatible with amd(requirejs) and can also be used in a standard script tag.\n\n### Example 1.\n\nIn this example we compile rules definitions inlined in a script tag.\n\n```html\n<script type=\"text/javascript\" src=\"nools.js\"></script>\n<script type=\"text/nools\" id=\"simple\">\ndefine Message {\n    message : \"\",\n    constructor : function (message) {\n        this.message = message;\n    }\n}\n\nrule Hello {\n    when {\n        m : Message m.message =~ /^hello(\\\\s*world)?$/\n    }\n    then {\n        modify(m, function(){\n            this.message += \" goodbye\";\n        });\n    }\n}\n\nrule Goodbye {\n    when {\n        m : Message m.message =~ /.*goodbye$/\n    }\n    then {\n        document.getElementById(\"output\").innerHTML += m.message + \"</br>\";\n    }\n}\n</script>\n<script type=\"text/javascript\">\n    function init() {\n       //get the source\n       var source = document.getElementById(\"simple\").innerHTML;\n       //compile the source. The name option is required if compiling directly.\n       var flow = nools.compile(source, {name: \"simple\"}),\n                Message = flow.getDefined(\"message\"),\n                session = flow.getSession();\n        //assert your different messages\n        session.assert(new Message(\"goodbye\"));\n        session.assert(new Message(\"hello\"));\n        session.assert(new Message(\"hello world\"));\n        session.match();\n    }\n</script>\n```\n\n### Using a compiled dsl.\n\nYou may also use the `nools` executable to compile source into a browser friendly format skipping the need for compiling each time.\n\n```\nnools compile ./my/rules.nools > ./compiled.js\n```\n\nTo use the flow require the compile version either through a script tag, `amd/requirejs`, or `commonjs` require.\n\nIf you import the flow using a script tag you can get a reference to the flow by using `nools.getFlow`.\n\n```\nnools.getFlow(\"rules\");\n```\n\nYou may also specify the name of the flow when compiling, it defaults to the name of the nools file less \".nools\"\n\n```\nnools compile -n \"my rules\" ./my/rules.nools\n```\n\n```\nnools.getFlow(\"my rules\");\n```\n\nIf you are using requirejs or nools must be required using something other than `require(\"nools\")` then you can specify a location of the nools source.\n\n```\nnools compile -nl \"./location/to/nools\" ./my/rules.nools\n```\n\n### RequireJS examples\n\nExamples of using nools with require js are located in the [examples directory](./examples).\n\n\n\n# Examples\n\n<a name=\"fib\"></a>\n## Fibonacci\n\n```javascript\n\"use strict\";\n\nvar nools = require(\"nools\");\n\nvar Fibonacci = function (sequence, value) {\n    this.sequence = sequence;\n    this.value = value || -1;\n};\n\nvar Result = function (result) {\n    this.result = result || -1;\n};\n\n\nvar flow = nools.flow(\"Fibonacci Flow\", function (flow) {\n\n    flow.rule(\"Recurse\", [\n        [\"not\", Fibonacci, \"f\", \"f.sequence == 1\"],\n        [Fibonacci, \"f1\", \"f1.sequence != 1\"]\n    ], function (facts) {\n        var f2 = new Fibonacci(facts.f1.sequence - 1);\n        this.assert(f2);\n    });\n\n    flow.rule(\"Bootstrap\", [\n          Fibonacci, \"f\", \"f.value == -1 && (f.sequence == 1 || f.sequence == 2)\"\n    ], function (facts) {\n        var f = facts.f;\n        f.value = 1;\n        this.modify(f);\n    });\n\n    flow.rule(\"Calculate\", [\n        [Fibonacci, \"f1\", \"f1.value != -1\", {sequence:\"s1\"}],\n        [Fibonacci, \"f2\", \"f2.value != -1 && f2.sequence == s1 + 1\", {sequence:\"s2\"}],\n        [Fibonacci, \"f3\", \"f3.value == -1 && f3.sequence == s2 + 1\"],\n        [Result, \"r\"]\n    ], function (facts) {\n        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\n        var v = f3.value = f1.value + facts.f2.value;\n        facts.r.result = v;\n        this.modify(f3);\n        this.retract(f1);\n    });\n});\n\nvar r1 = new Result(),\n    session1 = flow.getSession(new Fibonacci(10), r1),\n    s1 = new Date;\nsession1.match().then(function () {\n    console.log(\"%d [%dms]\", r1.result, new Date - s1);\n    session1.dispose();\n});\n\nvar r2 = new Result(),\n    session2 = flow.getSession(new Fibonacci(150), r2),\n    s2 = new Date;\nsession2.match().then(function () {\n    console.log(\"%d [%dms]\", r2.result, new Date - s2);\n    session2.dispose();\n});\n\nvar r3 = new Result(),\n    session3 = flow.getSession(new Fibonacci(1000), r3),\n    s3 = new Date;\nsession3.match().then(function () {\n    console.log(\"%d [%dms]\", r3.result, new Date - s3);\n    session3.dispose();\n});\n\n```\n\nOutput\n\n```\n55 [43ms]\n9.969216677189305e+30 [383ms]\n4.346655768693743e+208 [3580ms]\n```\n\n### Fibonacci with nools DSL\n\n```\n//Define our object classes, you can\n//also declare these outside of the nools\n//file by passing them into the compile method\ndefine Fibonacci {\n    value:-1,\n    sequence:null\n}\ndefine Result {\n    value : -1\n}\n\nrule Recurse {\n    when {\n        //you can use not or or methods in here\n        not(f : Fibonacci f.sequence == 1);\n        //f1 is how you can reference the fact else where\n        f1 : Fibonacci f1.sequence != 1;\n    }\n    then {\n        assert(new Fibonacci({sequence : f1.sequence - 1}));\n    }\n}\n\nrule Bootstrap {\n   when {\n       f : Fibonacci f.value == -1 && (f.sequence == 1 || f.sequence == 2);\n   }\n   then{\n       modify(f, function(){\n           this.value = 1;\n       });\n   }\n}\n\nrule Calculate {\n    when {\n        f1 : Fibonacci f1.value != -1 {sequence : s1};\n        //here we define constraints along with a hash so you can reference sequence\n        //as s2 else where\n        f2 : Fibonacci f2.value != -1 && f2.sequence == s1 + 1 {sequence:s2};\n        f3 : Fibonacci f3.value == -1 && f3.sequence == s2 + 1;\n        r : Result\n    }\n    then {\n        modify(f3, function(){\n            this.value = r.result = f1.value + f2.value;\n        });\n        retract(f1);\n    }\n}\n\n```\n\nAnd to run\n\n```javascript\nvar flow = nools.compile(__dirname + \"/fibonacci.nools\");\n\nvar Fibonacci = flow.getDefined(\"fibonacci\"), Result = flow.getDefined(\"result\");\nvar r1 = new Result(),\n    session1 = flow.getSession(new Fibonacci({sequence:10}), r1),\n    s1 = +(new Date());\nsession1.match().then(function () {\n    console.log(\"%d [%dms]\", r1.result, +(new Date()) - s1);\n    session1.dispose();\n});\n\nvar r2 = new Result(),\n    session2 = flow.getSession(new Fibonacci({sequence:150}), r2),\n    s2 = +(new Date());\nsession2.match().then(function () {\n    console.log(\"%d [%dms]\", r2.result, +(new Date()) - s2);\n    session2.dispose();\n});\n\nvar r3 = new Result(),\n    session3 = flow.getSession(new Fibonacci({sequence:1000}), r3),\n    s3 = +(new Date());\nsession3.match().then(function () {\n    console.log(\"%d [%dms]\", r3.result, +(new Date()) - s3);\n    session3.dispose();\n});\n\n```\n\nLicense\n-------\n\nMIT <https://github.com/C2FO/nools/raw/master/LICENSE>\n\nMeta\n----\n\n* Code: `git clone git://github.com/C2FO/nools.git`\n",
  "readmeFilename": "readme.md",
  "_id": "nools@0.1.14",
  "dist": {
    "shasum": "370faeb6bc5640c1a27b36a91b4b7605f3ea82f5"
  },
  "_from": "nools@",
  "_resolved": "https://registry.npmjs.org/nools/-/nools-0.1.14.tgz"
}
